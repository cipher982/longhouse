from datetime import datetime
from typing import Any
from typing import Dict
from typing import List
from typing import Optional

# ---------------------------------------------------------------------------
# New *Run History* schemas
# ---------------------------------------------------------------------------
from pydantic import BaseModel
from pydantic import ConfigDict

from zerg.models.enums import FicheStatus
from zerg.models.enums import RunStatus
from zerg.models.enums import RunTrigger
from zerg.utils.time import UTCBaseModel


# Fiche schemas
class FicheBase(BaseModel):
    name: str
    system_instructions: str
    task_instructions: str
    model: str
    schedule: Optional[str] = None
    config: Optional[Dict[str, Any]] = None
    last_error: Optional[str] = None
    allowed_tools: Optional[List[str]] = None


class FicheCreate(BaseModel):
    """Schema for fiche creation. Name is auto-generated by backend."""

    # name field omitted - backend auto-generates "Fiche #<id>"
    system_instructions: str
    task_instructions: str
    model: str
    schedule: Optional[str] = None
    config: Optional[Dict[str, Any]] = None
    allowed_tools: Optional[List[str]] = None


class FicheUpdate(BaseModel):
    name: Optional[str] = None
    system_instructions: Optional[str] = None
    task_instructions: Optional[str] = None
    model: Optional[str] = None
    status: Optional[FicheStatus] = None
    schedule: Optional[str] = None
    config: Optional[Dict[str, Any]] = None
    last_error: Optional[str] = None
    allowed_tools: Optional[List[str]] = None


# ---------------------------------------------------------------------------
# Pydantic 2.x quirk: on some Python versions ForwardRef resolution fails when
# schema is imported *before* all referenced types are defined.  Calling
# `.model_rebuild()` ensures the internal TypeAdapter tree is fully resolved.
# This is a no-op if everything is already valid.
for _m in [FicheCreate]:
    try:
        _m.model_rebuild()
    except Exception:  # pragma: no cover – defensive only
        pass


class FicheMessage(UTCBaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    fiche_id: int
    role: str
    content: str
    timestamp: datetime


# ------------------------------------------------------------
# Authentication schemas (Stage 1)
# ------------------------------------------------------------


class UserOut(UTCBaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    email: str
    is_active: bool
    created_at: datetime
    display_name: Optional[str] = None
    avatar_url: Optional[str] = None
    prefs: Optional[Dict[str, Any]] = None
    last_login: Optional[datetime] = None
    role: str = "USER"

    # -------------------- Gmail integration (Phase-C) --------------------
    # Whether the authenticated user already connected their Gmail account.
    # Convenience flag derived from the presence of a refresh-token – exposed
    # so the WASM frontend can enable e-mail trigger creation without an
    # extra round-trip.
    gmail_connected: bool = False


# User profile update schema (partial)
class UserUpdate(BaseModel):
    display_name: Optional[str] = None
    avatar_url: Optional[str] = None
    prefs: Optional[Dict[str, Any]] = None


class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int  # seconds until expiry


# Thread Message schemas
class ThreadMessageBase(BaseModel):
    role: str
    content: str
    tool_calls: Optional[List[Dict[str, Any]]] = None
    tool_call_id: Optional[str] = None
    name: Optional[str] = None


class ThreadMessageCreate(ThreadMessageBase):
    sent_at: Optional[datetime] = None  # Client can provide send timestamp; server validates ±5min, or uses server time


class ThreadMessageResponse(UTCBaseModel, ThreadMessageBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    thread_id: int
    sent_at: datetime  # When message was sent (UTC, timezone-aware)
    processed: bool = False
    parent_id: Optional[int] = None
    # Fields for message type and tool display
    message_type: Optional[str] = None
    tool_name: Optional[str] = None


# Thread schemas
class ThreadBase(BaseModel):
    title: str
    fiche_state: Optional[Dict[str, Any]] = None
    memory_strategy: Optional[str] = "buffer"
    active: Optional[bool] = True
    thread_type: Optional[str] = "chat"  # Types: chat, scheduled, manual


class ThreadCreate(ThreadBase):
    fiche_id: int


class ThreadUpdate(BaseModel):
    title: Optional[str] = None
    fiche_state: Optional[Dict[str, Any]] = None
    memory_strategy: Optional[str] = None
    active: Optional[bool] = None
    thread_type: Optional[str] = None


class Thread(UTCBaseModel, ThreadBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    fiche_id: int
    created_at: datetime
    updated_at: datetime
    messages: List[ThreadMessageResponse] = []


class ThreadSummary(UTCBaseModel, ThreadBase):
    """Thread summary for list endpoints (no messages payload)."""

    model_config = ConfigDict(from_attributes=True)

    id: int
    fiche_id: int
    created_at: datetime
    updated_at: datetime


class Fiche(UTCBaseModel, FicheBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    owner_id: int
    owner: Optional[UserOut] = None
    status: str
    created_at: datetime
    updated_at: datetime
    messages: List[FicheMessage] = []
    # Deprecated field removed – scheduling is implied by `schedule`.
    next_run_at: Optional[datetime] = None
    last_run_at: Optional[datetime] = None
    last_error: Optional[str] = None
    # Display type for UI (Phase 2 terminology rebrand)
    display_type: str = "fiche"


# ---------------------------------------------------------------------------
# Fiche Details schema (wrapper used by /fiches/{id}/details endpoint)
# ---------------------------------------------------------------------------


class FicheDetails(BaseModel):
    """Envelope object returned by the Fiche *details* REST endpoint.

    In Phase 1 we only populate the mandatory ``fiche`` field.  The optional
    ``threads``, ``runs`` and ``stats`` keys are included so that the response
    shape is forwards-compatible with the richer payloads planned for future
    phases (see *fiche_debug_modal_design.md*).
    """

    fiche: Fiche
    # The following fields will be filled in future phases when the client
    # requests additional includes via the `include` query param.
    threads: Optional[List[Thread]] = None  # noqa: F821 – Thread is declared later in this file
    runs: Optional[List[Any]] = None  # Placeholder for run log entries
    stats: Optional[Dict[str, Any]] = None


# Message schemas
class MessageCreate(BaseModel):
    role: str
    content: str


class MessageResponse(UTCBaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    fiche_id: int
    role: str
    content: str
    timestamp: datetime


# ------------------------------------------------------------
# Trigger schemas
# ------------------------------------------------------------


class TriggerBase(BaseModel):
    fiche_id: int
    type: str = "webhook"
    # Arbitrary configuration for non-webhook triggers (e.g. email server
    # settings).  For webhook triggers this is usually ``null``.
    config: Optional[Dict[str, Any]] = None


class TriggerCreate(TriggerBase):
    # Secret is generated by the server; client cannot supply it.
    pass


class Trigger(UTCBaseModel, TriggerBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    secret: str
    created_at: datetime


# ------------------------------------------------------------
# Run output schema (read-only, hence *Out* suffix)
# ------------------------------------------------------------


# RunStatus moved to models.enums for single source of truth


class RunOut(UTCBaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    fiche_id: int
    thread_id: int
    status: RunStatus
    trigger: RunTrigger
    started_at: Optional[datetime] = None
    finished_at: Optional[datetime] = None
    duration_ms: Optional[int] = None
    total_tokens: Optional[int] = None
    total_cost_usd: Optional[float] = None
    error: Optional[str] = None
    # Display type for UI (Phase 2 terminology rebrand)
    display_type: str = "run"


# ---------------------------------------------------------------------------
# Dashboard payload schemas
# ---------------------------------------------------------------------------


class RunBundle(BaseModel):
    fiche_id: int
    runs: List[RunOut] = []


class DashboardSnapshot(UTCBaseModel):
    scope: str
    fetched_at: datetime
    runs_limit: int
    fiches: List[Fiche]
    runs: List[RunBundle]


# ---------------------------------------------------------------------------
# Knowledge Base schemas (Phase 0)
# ---------------------------------------------------------------------------


class KnowledgeSourceBase(BaseModel):
    name: str
    source_type: str
    config: Dict[str, Any]
    sync_schedule: Optional[str] = None


class KnowledgeSourceCreate(KnowledgeSourceBase):
    pass


class KnowledgeSourceUpdate(BaseModel):
    name: Optional[str] = None
    config: Optional[Dict[str, Any]] = None
    sync_schedule: Optional[str] = None


class KnowledgeSource(UTCBaseModel, KnowledgeSourceBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    owner_id: int
    sync_status: str
    last_synced_at: Optional[datetime] = None
    sync_error: Optional[str] = None
    created_at: datetime
    updated_at: datetime


class KnowledgeDocumentBase(BaseModel):
    path: str
    title: Optional[str] = None
    content_text: str
    content_hash: str
    doc_metadata: Optional[Dict[str, Any]] = None


class KnowledgeDocument(UTCBaseModel, KnowledgeDocumentBase):
    model_config = ConfigDict(from_attributes=True)

    id: int
    source_id: int
    owner_id: int
    fetched_at: datetime


class KnowledgeSearchResult(BaseModel):
    """A search result from the knowledge base."""

    source_name: str
    source_id: int
    document_id: int
    path: str
    title: Optional[str] = None
    snippets: List[str]  # Matching text excerpts
    score: float  # Relevance score
    # V1.1: Provenance - immutable permalink to exact version (if available)
    permalink: Optional[str] = None
