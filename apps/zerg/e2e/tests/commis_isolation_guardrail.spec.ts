/**
 * Commis Isolation Guardrail Test
 *
 * Verifies that the E2E Postgres schema isolation is working correctly.
 * Each commis ID routes to a separate schema (e2e_commis_X).
 *
 * IMPORTANT: Uses unique guardrail-only commis IDs to avoid colliding
 * with real parallel test commis (0-15).
 */

import { test as base, expect } from './fixtures';

// Use numeric commis IDs outside the normal range (0-15) to avoid collisions
// The E2E test setup only creates schemas for IDs 0-15, but also supports
// any numeric ID via dynamic schema creation in the DB routing layer.
// Note: Using string IDs like 'guardrail_a' doesn't work because schemas
// are only created for numeric commis IDs.
const WORKER_ID_A = '100';
const WORKER_ID_B = '101';

const backendUrl = `http://127.0.0.1:${process.env.BACKEND_PORT || '8001'}`;

base.describe('Schema Isolation Guardrail', () => {
  // Generate unique markers to identify our fiches (name is auto-generated by backend)
  const uniqueMarker = `guardrail_${Date.now()}`;
  const markerA = `Fiche_A_${uniqueMarker}`;
  const markerB = `Fiche_B_${uniqueMarker}`;

  let requestA: Awaited<ReturnType<typeof base.request.newContext>>;
  let requestB: Awaited<ReturnType<typeof base.request.newContext>>;

  base.beforeAll(async ({ playwright }) => {
    // Create API contexts for two isolated commis
    requestA = await playwright.request.newContext({
      baseURL: backendUrl,
      extraHTTPHeaders: { 'X-Test-Commis': WORKER_ID_A },
    });
    requestB = await playwright.request.newContext({
      baseURL: backendUrl,
      extraHTTPHeaders: { 'X-Test-Commis': WORKER_ID_B },
    });
  });

  base.afterAll(async () => {
    // Clean up contexts
    await requestA?.dispose();
    await requestB?.dispose();
  });

  base('data in commis A is NOT visible in commis B', async () => {
    // Sanity: confirm the backend is routing each commis ID to a different schema
    const schemaAResp = await requestA.get('/api/admin/debug/db-schema');
    expect(schemaAResp.ok(), `Failed schema debug A: ${await schemaAResp.text()}`).toBeTruthy();
    const schemaA = await schemaAResp.json();

    const schemaBResp = await requestB.get('/api/admin/debug/db-schema');
    expect(schemaBResp.ok(), `Failed schema debug B: ${await schemaBResp.text()}`).toBeTruthy();
    const schemaB = await schemaBResp.json();

    expect(schemaA.current_schema, `Commis A schema debug: ${JSON.stringify(schemaA)}`).toBeTruthy();
    expect(schemaB.current_schema, `Commis B schema debug: ${JSON.stringify(schemaB)}`).toBeTruthy();
    expect(schemaA.current_schema, `Expected different schemas but got same: A=${JSON.stringify(schemaA)} B=${JSON.stringify(schemaB)}`).not.toBe(
      schemaB.current_schema
    );

    // Commis A: Create an fiche with unique marker in system_instructions
    // (name field is auto-generated by backend, so we use system_instructions as marker)
    const createAResponse = await requestA.post('/api/fiches', {
      data: {
        system_instructions: markerA,
        task_instructions: 'Test task',
        model: 'gpt-mock',
      },
    });
    expect(createAResponse.ok(), `Failed to create fiche A: ${await createAResponse.text()}`).toBeTruthy();
    const createdFicheA = await createAResponse.json();
    expect(createdFicheA.system_instructions).toBe(markerA);

    // Commis B: Create an fiche with different unique marker
    const createBResponse = await requestB.post('/api/fiches', {
      data: {
        system_instructions: markerB,
        task_instructions: 'Test task',
        model: 'gpt-mock',
      },
    });
    expect(createBResponse.ok(), `Failed to create fiche B: ${await createBResponse.text()}`).toBeTruthy();
    const createdFicheB = await createBResponse.json();
    expect(createdFicheB.system_instructions).toBe(markerB);

    // Commis A: List fiches - should see Fiche A's marker, NOT Fiche B's marker
    const listAResponse = await requestA.get('/api/fiches');
    expect(listAResponse.ok()).toBeTruthy();
    const fichesA = await listAResponse.json();

    const instructionsA = fichesA.map((a: { system_instructions: string }) => a.system_instructions);
    expect(instructionsA).toContain(markerA);
    expect(instructionsA).not.toContain(markerB);

    // Commis B: List fiches - should see Fiche B's marker, NOT Fiche A's marker
    const listBResponse = await requestB.get('/api/fiches');
    expect(listBResponse.ok()).toBeTruthy();
    const fichesB = await listBResponse.json();

    const instructionsB = fichesB.map((a: { system_instructions: string }) => a.system_instructions);
    expect(instructionsB).toContain(markerB);
    expect(instructionsB).not.toContain(markerA);

    console.log(`âœ… Schema isolation verified: Commis A and B have separate data`);
  });
});
