/**
 * Worker Isolation Guardrail Test
 *
 * Verifies that the E2E Postgres schema isolation is working correctly.
 * Each worker ID routes to a separate schema (e2e_worker_X).
 *
 * IMPORTANT: Uses unique guardrail-only worker IDs to avoid colliding
 * with real parallel test workers (0-15).
 */

import { test as base, expect } from '@playwright/test';

// Use unique worker IDs that won't collide with real Playwright workers
const WORKER_ID_A = 'guardrail_a';
const WORKER_ID_B = 'guardrail_b';

const backendUrl = `http://127.0.0.1:${process.env.BACKEND_PORT || '8001'}`;

base.describe('Schema Isolation Guardrail', () => {
  // Generate unique markers to identify our agents (name is auto-generated by backend)
  const uniqueMarker = `guardrail_${Date.now()}`;
  const markerA = `Agent_A_${uniqueMarker}`;
  const markerB = `Agent_B_${uniqueMarker}`;

  let requestA: Awaited<ReturnType<typeof base.request.newContext>>;
  let requestB: Awaited<ReturnType<typeof base.request.newContext>>;

  base.beforeAll(async ({ playwright }) => {
    // Create API contexts for two isolated workers
    requestA = await playwright.request.newContext({
      baseURL: backendUrl,
      extraHTTPHeaders: { 'X-Test-Worker': WORKER_ID_A },
    });
    requestB = await playwright.request.newContext({
      baseURL: backendUrl,
      extraHTTPHeaders: { 'X-Test-Worker': WORKER_ID_B },
    });
  });

  base.afterAll(async () => {
    // Clean up contexts
    await requestA?.dispose();
    await requestB?.dispose();
  });

  base('data in worker A is NOT visible in worker B', async () => {
    // Sanity: confirm the backend is routing each worker ID to a different schema
    const schemaAResp = await requestA.get('/api/admin/debug/db-schema');
    expect(schemaAResp.ok(), `Failed schema debug A: ${await schemaAResp.text()}`).toBeTruthy();
    const schemaA = await schemaAResp.json();

    const schemaBResp = await requestB.get('/api/admin/debug/db-schema');
    expect(schemaBResp.ok(), `Failed schema debug B: ${await schemaBResp.text()}`).toBeTruthy();
    const schemaB = await schemaBResp.json();

    expect(schemaA.current_schema, `Worker A schema debug: ${JSON.stringify(schemaA)}`).toBeTruthy();
    expect(schemaB.current_schema, `Worker B schema debug: ${JSON.stringify(schemaB)}`).toBeTruthy();
    expect(schemaA.current_schema, `Expected different schemas but got same: A=${JSON.stringify(schemaA)} B=${JSON.stringify(schemaB)}`).not.toBe(
      schemaB.current_schema
    );

    // Worker A: Create an agent with unique marker in system_instructions
    // (name field is auto-generated by backend, so we use system_instructions as marker)
    const createAResponse = await requestA.post('/api/agents', {
      data: {
        system_instructions: markerA,
        task_instructions: 'Test task',
        model: 'gpt-mock',
      },
    });
    expect(createAResponse.ok(), `Failed to create agent A: ${await createAResponse.text()}`).toBeTruthy();
    const createdAgentA = await createAResponse.json();
    expect(createdAgentA.system_instructions).toBe(markerA);

    // Worker B: Create an agent with different unique marker
    const createBResponse = await requestB.post('/api/agents', {
      data: {
        system_instructions: markerB,
        task_instructions: 'Test task',
        model: 'gpt-mock',
      },
    });
    expect(createBResponse.ok(), `Failed to create agent B: ${await createBResponse.text()}`).toBeTruthy();
    const createdAgentB = await createBResponse.json();
    expect(createdAgentB.system_instructions).toBe(markerB);

    // Worker A: List agents - should see Agent A's marker, NOT Agent B's marker
    const listAResponse = await requestA.get('/api/agents');
    expect(listAResponse.ok()).toBeTruthy();
    const agentsA = await listAResponse.json();

    const instructionsA = agentsA.map((a: { system_instructions: string }) => a.system_instructions);
    expect(instructionsA).toContain(markerA);
    expect(instructionsA).not.toContain(markerB);

    // Worker B: List agents - should see Agent B's marker, NOT Agent A's marker
    const listBResponse = await requestB.get('/api/agents');
    expect(listBResponse.ok()).toBeTruthy();
    const agentsB = await listBResponse.json();

    const instructionsB = agentsB.map((a: { system_instructions: string }) => a.system_instructions);
    expect(instructionsB).toContain(markerB);
    expect(instructionsB).not.toContain(markerA);

    console.log(`âœ… Schema isolation verified: Worker A and B have separate data`);
  });
});
