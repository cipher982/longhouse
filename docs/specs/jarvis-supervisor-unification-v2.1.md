# Jarvis ↔ Supervisor Unification (v2.1)

**Date:** December 19, 2025
**Audience:** Implementation handoff (Jarvis web + Zerg backend)
**Status:** Proposed (supersedes parts of `docs/specs/super-siri-architecture.md` v2.0)

## 0) Executive Summary

We are finalizing the “one brain” model:

- **Supervisor is the only brain** (reasoning, history, and _all tools_).
- **Workers are an execution primitive**, not a separate “mode” the user needs to understand.
- **Realtime is optional**. If kept, it is **I/O only** (mic/VAD/transcription + optional low-level turn-taking), and must never generate assistant responses or call tools.

This spec removes the remaining “third layer” plumbing (`route_to_supervisor`) and eliminates “two brains talking” by preventing OpenAI Realtime from ever creating a model response.

---

## 1) Goals / Non-goals

### Goals

1. **Single Brain**: exactly one assistant response per user utterance, generated by Supervisor.
2. **Supervisor Owns Tools**: Supervisor can decide “direct tool call” vs “spawn worker” without capability gaps.
3. **SSOT History**: server-side thread/messages are canonical; clients display what the brain sees.
4. **Voice UX preserved**: hands-free + barge-in feel good (when Realtime is enabled).
5. **Simplify codepaths**: one streaming mechanism in Jarvis web for Supervisor output.

### Non-goals (for this pass)

- Perfect streaming TTS with sub-200ms latency.
- Full removal of Realtime on day one (we keep it as optional, behind a clear architecture boundary).
- Rebuilding all “personal tools” if they depend on unreachable local resources (we define a clean path, implement incrementally).

---

## 2) Current State (December 2025 - Post React Migration)

### What matches the goal (implemented)

- Voice transcripts are routed to Supervisor (`apps/jarvis/apps/web/src/hooks/useJarvisApp.ts` handles transcripts)
- Typed text is routed to Supervisor (`apps/jarvis/apps/web/src/hooks/useTextChannel.ts` uses `SupervisorChatController` → POST `/api/jarvis/chat`)
- Supervisor is server-side SSOT for history (loaded during initialization)
- React-only architecture (no bridge mode, no legacy controllers)

### Remaining work

- `route_to_supervisor` cleanup in backend prompts
- Personal tools migration to Supervisor (get_current_location, get_whoop_data, search_notes)

### Supervisor streaming

- `/api/jarvis/chat`: fetch + manual SSE parsing (`apps/jarvis/apps/web/lib/supervisor-chat-controller.ts`)
- `/api/jarvis/supervisor/events`: EventSource streaming (`apps/jarvis/packages/core/src/jarvis-api-client.ts`)

---

## 3) Target Architecture (v2.1)

### 3.1 Canonical flow (always true)

**All user intent goes to Supervisor**:

- Text input → Supervisor
- Voice transcript (final) → Supervisor

**All assistant content comes from Supervisor**:

- UI renders Supervisor’s streamed content only.
- Voice output (TTS) speaks Supervisor content only.

### 3.2 Realtime (if enabled) is strictly an I/O peripheral

Realtime responsibilities:

- microphone transport (WebRTC)
- VAD/turn-taking (start/stop signals)
- transcription events (partial + final)

Realtime must **not**:

- generate assistant responses (text or audio)
- call tools (including `route_to_supervisor`)
- own history / “remember” anything (optional: can receive a tiny context, but it must not speak)

### 3.3 Supervisor “has all tools”

Supervisor owns all capabilities. It chooses:

- **Direct tool** (fast, single-shot, minimal output) vs
- **spawn_worker** (multi-step, verbose, parallelizable, risky, or slow)

Workers remain essential, but are subordinate to Supervisor’s decision-making (and invisible to the user unless we want to show progress).

---

## 4) Hard Requirements (must-haves)

### R1: Prevent Realtime from responding (no second brain)

This is the single most important implementation requirement.

Implementation requirements:

1. Configure Realtime turn detection with **`create_response=false`** so the server does not automatically create a response at end-of-turn.
   - Code lives in `apps/jarvis/apps/web/lib/session-handler.ts` (`SESSION_CONFIG.turnDetection`).
   - With the current SDK, this maps to `turn_detection.create_response` under the hood.
2. Ensure Jarvis web never calls APIs that create a Realtime response:
   - Do not call `session.sendMessage(...)` for typed chat (typed chat goes to Supervisor).
   - Do not create Realtime function/tool outputs that trigger responses (Realtime has no tools).
3. Defense-in-depth: ignore/never render Realtime `response.*` output events in UI.
   - The UI must only render Supervisor output.

Acceptance criteria:

- Speaking into the mic yields **exactly one** assistant message, from Supervisor.
- No Realtime `response.output_*` content appears in the chat UI.

### R2: Remove `route_to_supervisor` end-to-end

This is not a “maybe”. Once transcripts/text go directly to Supervisor, a delegation tool is conceptually wrong and creates confusion.

Implementation requirements:

- Remove `route_to_supervisor` tool registration from the Realtime session tool list.
- Stop advertising it in `/api/jarvis/bootstrap`.
- Remove it from Jarvis prompts (both server bootstrap prompt + any client fallback context text).
- Delete or rewrite tests that assert it exists.

Acceptance criteria:

- Bootstrap `enabled_tools` does not include `route_to_supervisor`.
- No codepath in Jarvis web calls `/api/jarvis/supervisor` as part of normal UX.

### R3: Supervisor is the only place tools live

All “personal tools” (location / whoop / notes) become Supervisor tools, not browser tools.

Implementation requirements:

- Jarvis web removes direct tool plumbing (no browser calling `/api/jarvis/tool`).
- Supervisor gets tool implementations with clear latency semantics:
  - “fast direct tool” vs “spawn worker”.

Acceptance criteria:

- “What’s my WHOOP recovery?” works via Supervisor without Realtime tool calls.
- “Search my notes for X” works via Supervisor tool or via worker behind a Supervisor tool (see §6.3).

---

## 5) API Contract (keep + evolve)

### 5.1 Primary Jarvis UI endpoint: `POST /api/jarvis/chat`

This stays the canonical “user said something” endpoint for the UI.

Required behavior:

- Streams SSE including:
  - `connected` (with `run_id` and optional `client_correlation_id`)
  - `supervisor_started`
  - `supervisor_thinking`
  - `supervisor_complete` (final result)
  - `error`
  - `heartbeat`

Recommended evolution:

- Add worker lifecycle + worker tool events to `POST /api/jarvis/chat` SSE stream (so Jarvis web can show the same progress UI without using `/supervisor/events`).
  - Mirror the event set used by `/api/jarvis/supervisor/events`:
    - `worker_spawned`, `worker_started`, `worker_complete`, `worker_summary_ready`
    - `worker_tool_started`, `worker_tool_completed`, `worker_tool_failed`

### 5.2 Keep `/api/jarvis/supervisor` + `/api/jarvis/supervisor/events` as “programmatic”

These can remain for:

- integrations
- debugging
- dashboard/dev tooling

But Jarvis web should not depend on them for normal UX once `/chat` streams full progress.

---

## 6) Tooling Model (Supervisor owns tools)

### 6.1 Rule of thumb for Supervisor

- **Direct tool call** when:
  - single call
  - bounded output
  - low risk
  - quick (< ~2s)
- **spawn_worker** when:
  - multi-step investigation
  - logs / verbose output likely
  - needs shell access
  - parallel checks
  - flaky external dependencies (SSH, network, rate limits)

### 6.2 Implement personal tools as Supervisor tools

We standardize tool names to match what Jarvis UI expects to claim (keep human-friendly names):

- `get_current_location`
- `get_whoop_data`
- `search_notes`

Each is a Supervisor tool (LangChain `StructuredTool`) and should be added to Supervisor’s allowlist in `apps/zerg/backend/zerg/services/supervisor_service.py`.

### 6.3 Important constraint: where the data lives

Some “personal tools” may rely on **local-only** resources (e.g., an Obsidian vault on a laptop).

We support two implementation strategies:

**Strategy A (best when backend has access):** MCP/HTTP direct

- Supervisor tool calls the integration directly from backend (e.g., WHOOP API, hosted MCP endpoint).

**Strategy B (best for local/private resources):** Runner-backed “direct tool”

- Supervisor tool calls `runner_exec` against a user-owned Runner (often on the laptop/home server).
- The tool is still a “direct tool” from the Supervisor’s perspective (no worker needed), but execution happens on the Runner.

Acceptance criteria for Strategy B:

- Tool execution is bounded and returns a compact result (no raw dumps).
- Failure mode is explicit (“no runner online” → guide runner setup).

---

## 7) Jarvis Web UI Behavior (single output stream)

### 7.1 UI renders only Supervisor messages

UI message rendering rules:

- User text messages: render immediately on send.
- User voice messages: render transcript when final transcription arrives.
- Assistant messages: render only when received from Supervisor stream.

Realtime events are used only for:

- transcript preview (partial)
- transcript finalization
- voice UI state (listening/speaking indicators), but **not** assistant content.

### 7.2 TTS output

MVP:

- Use browser TTS (Web Speech API) to speak Supervisor content.
- Stop/cancel TTS when user starts speaking (barge-in feel).

Future:

- Replace with streaming TTS (server or client) if needed for voice quality/latency.

---

## 8) Implementation Roadmap (handoff plan)

### Phase 1 — Stop the “two brains talking” (highest priority)

**Outcome:** Realtime cannot produce assistant output; Supervisor is the only speaker.

Tasks:

- Update Realtime session config to set `turnDetection.create_response=false`.
- Remove/disable UI rendering of Realtime `response.*` output events.
- Ensure typed text never goes through Realtime sendMessage; it must go to Supervisor only.

Acceptance:

- Voice transcript produces exactly one Supervisor response.

### Phase 2 — Delete the third layer (`route_to_supervisor`)

**Outcome:** No delegation tool exists in Realtime; no keyword routing semantics remain.

Tasks:

- ~~Remove `route_to_supervisor` tool from Jarvis web~~ (DONE - legacy controllers deleted)
- Remove it from `/api/jarvis/bootstrap` tool list + prompt text.
- Update docs/specs that claim the old model (or mark deprecated).

Acceptance:

- `route_to_supervisor` cannot be called because it no longer exists.

### Phase 3 — One Supervisor streaming path for Jarvis web

**Outcome:** Jarvis web needs only `/api/jarvis/chat` for Supervisor output + progress.

Tasks:

- Extend `/api/jarvis/chat` SSE generator to also subscribe to worker + worker tool events (parity with `/supervisor/events`).
- Update `SupervisorChatController` (`apps/jarvis/apps/web/lib/supervisor-chat-controller.ts`) to handle those events and publish `stateManager` updates for progress UI.
- Deprecate any Jarvis web usage of `JarvisAPIClient.executeSupervisorTask()` path.

Acceptance:

- Progress UI (workers + tool ticker) works in chat mode without `/supervisor/events`.

### Phase 4 — Move personal tools fully into Supervisor

**Outcome:** Supervisor can do quick personal tasks without involving Realtime tools.

Tasks:

- Implement `get_current_location`, `get_whoop_data`, `search_notes` as Supervisor tools.
- Choose integration strategy per tool:
  - WHOOP: direct API from backend or MCP
  - Location: direct API or Runner-backed
  - Obsidian: likely Runner-backed
- Add these tools to Supervisor allowlist.
- Update bootstrap tool list/prompt to reflect reality (Supervisor can do them).

Acceptance:

- These tasks work through Supervisor with consistent auth and observability.

### Phase 5 (Optional) — Remove Realtime entirely (STT sandwich)

**Outcome:** Voice pipeline becomes: streaming STT → Supervisor → TTS.

Only do this if:

- Realtime adds complexity without UX benefit after Phases 1–4.
- We can preserve barge-in/turn-taking adequately.

---

## 9) Open Questions (explicit decisions for the dev)

1. Realtime enablement: keep always-on or behind a flag (recommended: `VITE_JARVIS_ENABLE_REALTIME=true/false`)?
2. TTS implementation MVP: Web Speech API vs server TTS.
3. Personal tools integration:
   - Which ones must work from the backend (cloud API)?
   - Which ones must run on a Runner (local/private resources)?

---

## 10) Definition of Done (project-level)

- “One brain” invariant holds across text + voice.
- No `route_to_supervisor` anywhere in runtime codepaths.
- Supervisor owns tools and can decide direct vs worker.
- Jarvis web uses a single Supervisor stream path (`/api/jarvis/chat`) for UX.
- Docs reflect v2.1 direction (v2.0 marked partially deprecated).
